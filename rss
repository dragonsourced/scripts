#!/bin/sh

RSSD=$HOME/.sfeed/feeds
NEW_CACHE=${RSSD}/.new

NEW_IND='[33;1mN[0m'
OLD_IND=' '

cd "${RSSD}" || exit

[ "$DISPLAY" ] && transset --id "${WINDOWID}" "$(theme g termopacity)" > /dev/null 2> /dev/null

# Simple menu wrapper.

_menu() {
	fzf --reverse --prompt "$* "
}

# Pager wrapper.

_pager() {
	sensible-pager
}

# Open links in a web browser.

_www() {
	if [ "$DISPLAY" ]; then
		x-www-browser "$@"
	else
		lynx "$@"
	fi
}

# Escape a string so it doesn't mess up my regexes.

_esc() {
    echo "$*" | sed -e 's/\[/\\[/g' -e 's/\]/\\]/g' -e 's/\*/\\*/g' -e 's/\./\\./g'
}

# Escape a single-quoted string.

_esc_sq() {
	echo "$*" # I haven't actually figured out how to do this yet.
}

# Update the RSS feeds.

_update() {
	# Don't bother actually updating if there's
	# no internet connection.
	ping -c1 -t1 8.8.8.8 && sfeed_update

	# Re-calculate the new entry cache.
	_cache_new
}

# Calculate the # of new entries in a feed,
# or # of new entries in the feeds within
# a directory.

_calc_new() {
	find "$*" -type f -exec cat {} \; | sfeed_fmt new | wc -l
}

_cache_new() { 
	:> "${NEW_CACHE}"
	find "${RSSD}" | while read -r __f; do
		echo "$__f	$(_calc_new "$__f")" >> "${NEW_CACHE}"
	done
}

_new() {
	[ -f "${NEW_CACHE}" ] || _cache_new
	__new2r=$(grep "^${PWD}/$*" < "${NEW_CACHE}" | cut -d'	' -f2)
	if [ "$__new2r" ]; then
		# converts possible erroneous strings
		echo "$((__new2r + 0))"
	else
		echo 0
	fi
}

# Display a feed or directory, when applicable.

_show_feed() {
	__new="$(_new "$*")"
	if [ "$__new" -gt 0 ]; then
		echo "$(basename "$*") ($__new new)"
	elif ! [ "$NEW_ONLY" ]; then
		basename "$*"
	fi
}

# Display all available feeds/directories.

_feeds() {
	find . -maxdepth 1 -mindepth 1 | while read -r __feed; do
		_show_feed "$__feed"
	done | grep -v '^\.'
}

# Select a feed.

_selfeed() {
	while pwd | grep -q "$RSSD"; do
		__feed=$(_feeds | fzf --prompt 'RSS '\
		    --reverse\
		    --preview="$0 startin \"$PWD\" list {}")

		[ "$__feed" ] || __feed=..

		__feed="$(_clean_feed "$__feed")"

		if [ -d "$__feed" ]; then
			cd "$__feed" || return
		elif [ -f "$__feed" ]; then
			_selentry "$__feed"
		fi
	done
}

# The string to grep for to find an entry in a feed.

_entry_regx() {
	echo "	$(_esc "$*")	"
}

# Find an entry from its title.
# Args: title, feed

_find_entry() {
	grep "$(_entry_regx "$1")" < "$2" | sed 1q
}

# Entries seem to wind up across multiple lines,
# even though they're encoded with non-literal
# \n's.  As such, I have to do this:

_fmt_entry() {
	echo "$*" | sed 's/$/ \n/' | tr -d '\n'
}

# Convert an entry into a formatted description.

_desc() {
	echo "$*"\
	    | sfeed_fmt content\
	    | lynx -dump -stdin
}

# Is the given entry a new one?
# Args: line #, feed

_is_new() {
	[ "$1" -le "$(_new "$2")" ]
}

# Display an entry in a feed.
# Args: entry title, feed, line #

_show_entry() {
	if _is_new "$3" "$2"; then
		echo "${NEW_IND} $1"
	else
		echo "${OLD_IND} $1"
	fi
}

# List all of the entries in a feed.

_list_entries() {
	___line_nr=0
	# shellcheck disable=SC2094
	sfeed_fmt title < "$*" | while read -r __list_entry; do
		___line_nr=$((___line_nr + 1))
		_show_entry "$__list_entry" "$*" "$___line_nr"
	done
}

# Clean an entry title of superfluous formatting,
# such as $NEW_IND.

_clean_entry() {
	echo "$*" | sed\
	    -e "s/^$(_esc "${NEW_IND}") //"\
	    -e "s/^$(_esc "${OLD_IND}") //"
}

# Same, but for feeds.

_clean_feed() {
	echo "$*" | sed 's/ ([0-9]* new)$//'
}

# Select an entry in a feed.

_selentry() {
	__feed="$*"
	while true; do
		__entry=$(_list_entries "$__feed" | fzf\
		    --reverse\
		    --prompt="$__feed "\
		    --preview="$0 startin \"$PWD\" preview {} \"$__feed\"")
		[ "$__entry" ] || break
		__entry="$(_clean_entry "$__entry")"
		_selopt "$(_find_entry "$__entry" "$__feed")" "$__feed"
	done
}

# List available options for an entry.

OPT_VID="Play video."
OPT_TITLE="View full title."
OPT_DESC="View description."
OPT_WWW="Open in a web browser."
OPT_CPY="Copy link to clipboard."

_opts() {
	echo "$OPT_VID"
	echo "$OPT_DESC"
	echo "$OPT_TITLE"
	echo "$OPT_WWW"
	echo "$OPT_CPY"
	echo ".."
}

# Select an option to interact with an entry.
# Args: entry

_selopt() {
	__entry="$(_fmt_entry "$*")"
	__title="$(echo "$__entry" | sfeed_fmt title)"
	__link="$(echo "$__entry" | sfeed_fmt link)"
	__opt="$(_opts "$__entry" | fzf\
	    --reverse\
	    --prompt="$__title "\
	    --preview="$0 startin \"$PWD\" Preview '$(_esc_sq "$__entry")'")"

	case $__opt in
		"$OPT_VID") ;;
		"$OPT_TITLE")
			clear
			echo "$__title" | _pager ;;
		"$OPT_DESC")
			clear
			_desc "$__entry" | _pager
			;;
		"$OPT_WWW")
			_www "$__link"
			;;
		"$OPT_CPY")
			echo "$__link" | xsel -bc
			;;
		*) return ;;
	esac

	_selopt "$*"
}

# Preview an entry in a feed by printing its description.
# Args: title, feed

_preview_entry() {
	_fmt_entry "$(_find_entry "$1" "$2")"\
		| sfeed_fmt content\
		| lynx -dump -stdin -width=${COLUMNS}\
		| sed ${LINES:-24}q
}

# Same as _preview_entry(), but the entry's already been found.
# Args: entry

_Preview_entry() {
	echo "$*"\
		| sfeed_fmt content\
		| lynx -dump -stdin -width=${COLUMNS}\
		| sed ${LINES:-24}q
}

# Count the number of entries currently present.

_count() {
	# Assumes 1 entry per line.
	find ${RSSD} -type f -exec cat {} \; | wc -l
}

# Update the RSS feeds, sending a notification if any new
# entries show up.

_update() {
	__old="$(_count)"
	sfeed_update
	_cache_new
	__new="$(_count)"
	if [ "$__new" -gt "$__old" ]; then
		notify-send RSS "$((__new - __old)) new entries."
	fi
}

if [ "$1" ]; then
	while [ "$1" ]; do
		case $1 in
			u|update)
				_update
				;;
			s|startin)
				cd "$2" || exit
				shift
				;;
			p|preview)
				_preview_entry "$(_clean_entry "$2")" "$3"
				shift
				shift
				;;
			P|Preview)
				_Preview_entry "$2"
				shift
				;;
			l|list)
				if [ -f "$2" ]; then
					_list_entries "$2"
				elif [ -d "$2" ]; then
					cd "$2" || return
					_feeds
				fi | sed ${LINES:-24}q
				shift
				;;
			n|new)
				NEW_ONLY=1 _selfeed
				;;
		esac
		shift
	done
else
	_selfeed
fi
