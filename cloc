#!/bin/sh

# Print info to standard output.

_out() {
	printf '%-16s %s\r\n' "$1" "$2"
}

# A seperator between sections.

_sep() {
	echo
}

# Specific cleanup procedures for different filetypes.

_c() {
	sed '/^[ 	]*.\*/d'
}

_sh() {
	grep -v '^[ 	]*#'
}

_py() {
	grep -v '^[ 	]*#'
	# I don't know yet how to properly handle multiline
	# docstrings, but I'll find out at some point.
}

# Clean output of comments, blank lines, etc., using the
# procedures defined above.

_clean() {
	while [ "$1" ]; do
		case $1 in
			*.c|*.h) _c < $1 ;;
			*.sh) _sh < $1 ;;
			*.py) _py < $1 ;;
			*.*) ;; # Not a known extension, so do nothing.
			*) _sh < $1 ;; # Hopefully a shell script.
		esac
		shift
	done | grep -v '^$'
}

# Turn cleaned source code into numerical information.

_count() {
	cat > /tmp/cloc
	(wc -c < /tmp/cloc; wc -l < /tmp/cloc) | sed 's/$/\t\t/g' | tr -d '\n'
	rm /tmp/cloc
}

# LOC for a file.

_file() {
	_clean $1 | _count
}

# Recursively call this command for every eligible
# file inside of a given directory.

_dir() {
	src=$(find $1 -type f\
	    | grep -v\
		-e '[/^]\.git'\
	    	-e '\.o$'\
	    | sed 's/^\.\///')
	for f in ${src}; do
		$0 "$f"
	done
	_sep
	_out TOTAL "$(_clean ${src} | _count)"
}

# If no arguments given, act on the current directory.

if ! [ "$1" ]; then
	set -- .
fi

# Actually do it.

while [ "$1" ]; do
	[ -d "$1" ] && (
		echo 'FILE             BYTES		LINES'
		_sep
		_dir "$1"
	)
	[ -f "$1" ] && _out "$1" "$(_file "$1")"
	shift
done
